'use client';

import React, { createContext, useContext, useState, useEffect, useCallback, useRef } from 'react';

const CMSContext = createContext();

export const useCMS = () => {
  const context = useContext(CMSContext);
  if (!context) {
    throw new Error('useCMS must be used within a CMSProvider');
  }
  return context;
};

export const CMSProvider = ({ children }) => {
  // Seiten Management
  const [pages, setPages] = useState([]);
  const [currentPage, setCurrentPage] = useState(null);
  const [isLoading, setIsLoading] = useState(false);

  // BlÃ¶cke Management mit intelligentem Batching
  const [blocks, setBlocks] = useState([]);
  const [pendingOperations, setPendingOperations] = useState(new Map()); // Map fÃ¼r Batching
  const [saveStatus, setSaveStatus] = useState('saved'); // 'saving', 'saved', 'error', 'dirty'
  const [lastSaveTime, setLastSaveTime] = useState(null);

  // Auto-Save Debouncing
  const autoSaveTimeoutRef = useRef(null);
  const AUTOSAVE_DELAY = 2000; // 2 Sekunden

  // Cleanup bei Unmount
  useEffect(() => {
    return () => {
      if (autoSaveTimeoutRef.current) {
        clearTimeout(autoSaveTimeoutRef.current);
      }
    };
  }, []);

  // Auto-Save wenn Ã„nderungen vorhanden
  useEffect(() => {
    if (pendingOperations.size > 0 && saveStatus === 'dirty') {
      // Clear existing timeout
      if (autoSaveTimeoutRef.current) {
        clearTimeout(autoSaveTimeoutRef.current);
      }
      
      // Set new timeout
      autoSaveTimeoutRef.current = setTimeout(() => {
        console.log('ðŸ”„ Auto-saving pending changes...');
        publishDrafts();
      }, AUTOSAVE_DELAY);
    }

    return () => {
      if (autoSaveTimeoutRef.current) {
        clearTimeout(autoSaveTimeoutRef.current);
      }
    };
  }, [pendingOperations.size, saveStatus]);

  // API Calls
  const loadPages = async () => {
    setIsLoading(true);
    try {
      const response = await fetch('/api/cms/pages');
      if (response.ok) {
        const data = await response.json();
        setPages(data);
        console.log('âœ… Pages loaded:', data.length);
      } else {
        throw new Error(`HTTP ${response.status}`);
      }
    } catch (error) {
      console.error('âŒ Error loading pages:', error);
      setSaveStatus('error');
    } finally {
      setIsLoading(false);
    }
  };

  const loadBlocks = async (pageId) => {
    if (!pageId) return;
    
    setIsLoading(true);
    try {
      const response = await fetch(`/api/cms/pages/${pageId}/blocks`);
      if (response.ok) {
        const data = await response.json();
        
        // Validiere und normalisiere Block-Daten
        const validBlocks = data.map(block => ({
          ...block,
          grid_col: typeof block.grid_col === 'number' && !isNaN(block.grid_col) ? block.grid_col : 0,
          grid_row: typeof block.grid_row === 'number' && !isNaN(block.grid_row) ? block.grid_row : 0,
          grid_width: typeof block.grid_width === 'number' && !isNaN(block.grid_width) ? block.grid_width : 2,
          grid_height: typeof block.grid_height === 'number' && !isNaN(block.grid_height) ? block.grid_height : 1,
          background_color: block.background_color || 'transparent',
          text_color: block.text_color || '#000000',
          z_index: typeof block.z_index === 'number' ? block.z_index : 1
        }));
        
        setBlocks(validBlocks);
        setPendingOperations(new Map()); // Clear pending operations
        setSaveStatus('saved');
        console.log(`âœ… Loaded ${validBlocks.length} blocks for page ${pageId}`);
      } else {
        throw new Error(`HTTP ${response.status}`);
      }
    } catch (error) {
      console.error('âŒ Error loading blocks:', error);
      setSaveStatus('error');
    } finally {
      setIsLoading(false);
    }
  };

  const selectPage = (page) => {
    setCurrentPage(page);
    if (page) {
      loadBlocks(page.id);
    } else {
      setBlocks([]);
      setPendingOperations(new Map());
      setSaveStatus('saved');
    }
  };

  // Persistente Draft-Ã„nderungen (Ã¼ber localStorage)
  useEffect(() => {
    if (currentPage) {
      const savedDrafts = localStorage.getItem(`nic-drafts-${currentPage.id}`);
      if (savedDrafts) {
        try {
          const parsedDrafts = JSON.parse(savedDrafts);
          setDraftChanges(parsedDrafts);
        } catch (error) {
          console.error('Fehler beim Laden der Draft-Ã„nderungen:', error);
        }
      }
    }
  }, [currentPage]);

  // Speichere Draft-Ã„nderungen in localStorage
  useEffect(() => {
    if (currentPage && draftChanges.length > 0) {
      localStorage.setItem(`nic-drafts-${currentPage.id}`, JSON.stringify(draftChanges));
    }
  }, [draftChanges, currentPage]);

  // Keyboard Shortcuts (Ctrl+Z, Ctrl+Y)
  useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.ctrlKey || e.metaKey) {
        if (e.key === 'z' && !e.shiftKey) {
          e.preventDefault();
          undo();
        } else if (e.key === 'y' || (e.key === 'z' && e.shiftKey)) {
          e.preventDefault();
          redo();
        }
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, []);

  // Undo/Redo Funktionen
  const undo = () => {
    if (undoHistory.length === 0) return;

    const lastAction = undoHistory[undoHistory.length - 1];
    setRedoHistory(prev => [...prev, { type: 'current_state', blocks: [...blocks] }]);
    setUndoHistory(prev => prev.slice(0, -1));

    // Wende die RÃ¼ckgÃ¤ngig-Operation an
    if (lastAction.type === 'add_block') {
      setBlocks(prev => prev.filter(block => block.id !== lastAction.blockId));
    } else if (lastAction.type === 'delete_block') {
      setBlocks(prev => [...prev, lastAction.block]);
    } else if (lastAction.type === 'update_block') {
      setBlocks(prev => prev.map(block =>
        block.id === lastAction.blockId ? lastAction.oldData : block
      ));
    }
  };

  const redo = () => {
    if (redoHistory.length === 0) return;

    const nextAction = redoHistory[redoHistory.length - 1];
    setUndoHistory(prev => [...prev, { type: 'current_state', blocks: [...blocks] }]);
    setRedoHistory(prev => prev.slice(0, -1));

    if (nextAction.type === 'current_state') {
      setBlocks(nextAction.blocks);
    }
  };

  // Hilfsfunktion fÃ¼r Undo-History
  const addToUndoHistory = (action) => {
    setUndoHistory(prev => [...prev.slice(-19), action]); // Maximal 20 Undo-Schritte
    setRedoHistory([]); // Redo-History zurÃ¼cksetzen
  };

  // API Calls
  const loadPages = async () => {
    setIsLoading(true);
    try {
      const response = await fetch('/api/cms/pages');
      const data = await response.json();
      setPages(data);
    } catch (error) {
      console.error('Fehler beim Laden der Seiten:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const loadBlocks = async (pageId) => {
    if (!pageId) return;
    setIsLoading(true);
    try {
      const response = await fetch(`/api/cms/blocks?pageId=${pageId}`);
      let data = await response.json();

      // Wende Draft-Ã„nderungen an (nur in NIC, nicht auf der verÃ¶ffentlichten Seite)
      data = applyDraftChangesToBlocks(data);

      setBlocks(data);
    } catch (error) {
      console.error('Fehler beim Laden der BlÃ¶cke:', error);
    } finally {
      setIsLoading(false);
    }
  };

  // Wende Draft-Ã„nderungen auf BlÃ¶cke an
  const applyDraftChangesToBlocks = (originalBlocks) => {
    let modifiedBlocks = [...originalBlocks];

    draftChanges.forEach(change => {
      if (change.type === 'add') {
        // TemporÃ¤re IDs fÃ¼r Draft-BlÃ¶cke
        const tempBlock = {
          id: `temp-${change.id}`,
          page_id: currentPage?.id,
          block_type: change.blockType,
          content: getDefaultContent(change.blockType),
          position_x: 10 + (modifiedBlocks.length * 5),
          position_y: 10 + (modifiedBlocks.length * 5),
          width: 20,
          height: 20,
          rotation: 0,
          scale_x: 1,
          scale_y: 1,
          z_index: Math.max(...modifiedBlocks.map(b => b.z_index || 0), 0) + 1,
          background_color: '#ffffff',
          text_color: '#000000',
          order_index: modifiedBlocks.length,
          isDraft: true // Markierung fÃ¼r Draft-BlÃ¶cke
        };
        modifiedBlocks.push(tempBlock);
      } else if (change.type === 'delete') {
        modifiedBlocks = modifiedBlocks.filter(block => block.id !== change.blockId);
      } else if (change.type === 'update') {
        modifiedBlocks = modifiedBlocks.map(block =>
          block.id === change.blockId ? { ...block, ...change.data } : block
        );
      }
    });

    return modifiedBlocks;
  };

  const createPage = async (title, slug) => {
    try {
      const response = await fetch('/api/cms/pages', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ title, slug })
      });
      const newPage = await response.json();
      setPages(prev => [newPage, ...prev]);
      return newPage;
    } catch (error) {
      console.error('Fehler beim Erstellen der Seite:', error);
      throw error;
    }
  };

  const updatePage = async (id, title, slug) => {
    try {
      const response = await fetch(`/api/cms/pages/${id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ title, slug })
      });
      const updatedPage = await response.json();
      setPages(prev => prev.map(page => page.id === id ? updatedPage : page));
      if (currentPage && currentPage.id === id) {
        setCurrentPage(updatedPage);
      }
      return updatedPage;
    } catch (error) {
      console.error('Fehler beim Aktualisieren der Seite:', error);
      throw error;
    }
  };

  const deletePage = async (id) => {
    try {
      await fetch(`/api/cms/pages/${id}`, { method: 'DELETE' });
      setPages(prev => prev.filter(page => page.id !== id));
      if (currentPage && currentPage.id === id) {
        setCurrentPage(null);
        setBlocks([]);
      }
    } catch (error) {
      console.error('Fehler beim LÃ¶schen der Seite:', error);
      throw error;
    }
  };

  const createBlock = (blockData) => {
    // UnterstÃ¼tze sowohl alten blockType String als auch neues blockData Objekt
    if (typeof blockData === 'string') {
      // Legacy: nur blockType wurde Ã¼bergeben
      const blockType = blockData;
      const draftId = Date.now();

      const newDraftChange = {
        id: draftId,
        type: 'add',
        blockType: blockType,
        timestamp: Date.now()
      };

      addToUndoHistory({
        type: 'undo_add',
        draftChangeId: draftId
      });

      setDraftChanges(prev => {
        const updated = [...prev, newDraftChange];
        localStorage.setItem('cms_draft_changes', JSON.stringify(updated));
        return updated;
      });
    } else {
      // Neue Implementierung: Komplettes Block-Objekt
      const newBlock = {
        id: `temp-${Date.now()}`,
        page_id: currentPage?.id,
        ...blockData,
        isDraft: true,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };

      addToUndoHistory({
        type: 'add_block',
        blockId: newBlock.id
      });

      // Direkt zu blocks hinzufÃ¼gen (fÃ¼r sofortige UI-Updates)
      setBlocks(prev => [...prev, newBlock]);
    }
  };

  const updateBlock = (id, blockData) => {
    // Speichere aktuellen Block-Zustand fÃ¼r Undo
    const currentBlock = blocks.find(b => b.id === id);
    if (currentBlock) {
      addToUndoHistory({
        type: 'update_block',
        blockId: id,
        oldData: { ...currentBlock }
      });
    }

    // Aktualisiere Block direkt im State fÃ¼r sofortige UI-Updates
    setBlocks(prev => prev.map(block =>
      block.id === id ? { ...block, ...blockData, updated_at: new Date().toISOString() } : block
    ));

    // ZusÃ¤tzlich: Erstelle Draft-Ã„nderung fÃ¼r eventuelle spÃ¤tere Persistierung
    const newDraftChange = {
      id: Date.now(),
      type: 'update',
      blockId: id,
      data: blockData,
      timestamp: Date.now()
    };

    setDraftChanges(prev => {
      const updated = [...prev, newDraftChange];
      localStorage.setItem('cms_draft_changes', JSON.stringify(updated));
      return updated;
    });
  };

  const deleteBlock = (id) => {
    // Speichere Block fÃ¼r Undo
    const blockToDelete = blocks.find(b => b.id === id);
    if (blockToDelete) {
      addToUndoHistory({
        type: 'delete_block',
        block: { ...blockToDelete }
      });
    }

    // Entferne Block direkt aus State fÃ¼r sofortige UI-Updates
    setBlocks(prev => prev.filter(block => block.id !== id));

    // Erstelle Draft-Ã„nderung fÃ¼r eventuelle spÃ¤tere Persistierung
    const newDraftChange = {
      id: Date.now(),
      type: 'delete',
      blockId: id,
      timestamp: Date.now()
    };

    setDraftChanges(prev => {
      const updated = [...prev, newDraftChange];
      localStorage.setItem('cms_draft_changes', JSON.stringify(updated));
      return updated;
    });

    if (activeBlock && activeBlock.id === id) {
      setActiveBlock(null);
    }
  };

  // VerÃ¶ffentliche alle Draft-Ã„nderungen in die Datenbank
  const publishDrafts = async () => {
    if (draftChanges.length === 0) return;

    try {
      for (const change of draftChanges) {
        if (change.type === 'add') {
          const blockData = {
            page_id: currentPage.id,
            block_type: change.blockType,
            content: getDefaultContent(change.blockType),
            position_x: 10 + (blocks.length * 5),
            position_y: 10 + (blocks.length * 5),
            width: 20,
            height: 20,
            rotation: 0,
            scale_x: 1,
            scale_y: 1,
            z_index: Math.max(...blocks.map(b => b.z_index || 0), 0) + 1,
            background_color: '#ffffff',
            text_color: '#000000',
            order_index: blocks.length
          };

          await fetch('/api/cms/blocks', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(blockData)
          });
        } else if (change.type === 'update') {
          await fetch(`/api/cms/blocks/${change.blockId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(change.data)
          });
        } else if (change.type === 'delete') {
          await fetch(`/api/cms/blocks/${change.blockId}`, {
            method: 'DELETE'
          });
        }
      }

      // LÃ¶sche Draft-Ã„nderungen nach VerÃ¶ffentlichung
      setDraftChanges([]);
      localStorage.removeItem('cms_draft_changes');

      // Lade verÃ¶ffentlichte BlÃ¶cke
      loadBlocks(currentPage?.id);

    } catch (error) {
      console.error('Fehler beim VerÃ¶ffentlichen der Drafts:', error);
    }
  };

  const loadLayoutSettings = async () => {
    try {
      const response = await fetch('/api/cms/layout');
      const data = await response.json();
      setLayoutSettings(data);
    } catch (error) {
      console.error('Fehler beim Laden der Layout-Einstellungen:', error);
    }
  };

  const updateLayoutSettings = async (settings) => {
    try {
      const response = await fetch('/api/cms/layout', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(settings)
      });
      const updatedSettings = await response.json();
      setLayoutSettings(updatedSettings);
      return updatedSettings;
    } catch (error) {
      console.error('Fehler beim Aktualisieren der Layout-Einstellungen:', error);
      throw error;
    }
  };

  const getDefaultContent = (blockType) => {
    switch (blockType) {
      case 'Text':
        return 'Neuer Text';
      case 'ImageBlock':
        return '';
      case 'ButtonBlock':
        return 'Button';
      case 'VideoBlock':
        return '';
      case 'ContainerBlock':
        return 'Container';
      default:
        return '';
    }
  };

  // Grid Helper Functions
  const snapToGridValue = (value, gridSize, containerSize) => {
    if (!snapToGrid) return value;

    const pixelValue = (value * containerSize) / 100;
    const snappedPixel = Math.round(pixelValue / gridSize) * gridSize;
    return (snappedPixel / containerSize) * 100;
  };

  const getSnapLines = () => {
    if (!snapToElements) return [];

    const lines = [];
    blocks.forEach(block => {
      if (block.id === activeBlock?.id) return; // Ignore active block

      // Vertikale Linien
      lines.push({
        type: 'vertical',
        pos: block.position_x,
        range: [block.position_y, block.position_y + block.height]
      });
      lines.push({
        type: 'vertical',
        pos: block.position_x + block.width,
        range: [block.position_y, block.position_y + block.height]
      });

      // Horizontale Linien
      lines.push({
        type: 'horizontal',
        pos: block.position_y,
        range: [block.position_x, block.position_x + block.width]
      });
      lines.push({
        type: 'horizontal',
        pos: block.position_y + block.height,
        range: [block.position_x, block.position_x + block.width]
      });
    });

    return lines;
  };

  const selectBlock = (block) => {
    setActiveBlock(block);
    if (!selectedBlocks.find(b => b.id === block.id)) {
      setSelectedBlocks([block]);
    }
  };

  const deselectAllBlocks = () => {
    setActiveBlock(null);
    setSelectedBlocks([]);
  };

  const duplicateBlock = async (block) => {
    const duplicatedData = {
      ...block,
      id: undefined,
      position_x: block.position_x + 5,
      position_y: block.position_y + 5,
      z_index: Math.max(...blocks.map(b => b.z_index || 0), 0) + 1,
      order_index: blocks.length
    };
    delete duplicatedData.id;
    delete duplicatedData.created_at;
    delete duplicatedData.updated_at;

    return await createBlock(duplicatedData);
  };

  // Initialisierung
  useEffect(() => {
    loadPages();
    loadLayoutSettings();
  }, []);

  useEffect(() => {
    if (currentPage) {
      loadBlocks(currentPage.id);
    }
  }, [currentPage]);

  const value = {
    // State
    pages,
    currentPage,
    blocks,
    activeBlock,
    selectedBlocks,
    mode,
    sidebarOpen,
    layoutSettings,
    draggedBlock,
    isDragging,
    containerSize,
    isLoading,
    draftChanges,
    undoHistory,
    redoHistory,
    gridEnabled,
    gridSize,
    snapToGrid,
    showGrid,
    snapToElements,

    // Setters
    setPages,
    setCurrentPage,
    setBlocks,
    setActiveBlock,
    setSelectedBlocks,
    setMode,
    setSidebarOpen,
    setLayoutSettings,
    setDraggedBlock,
    setIsDragging,
    setContainerSize,
    setGridEnabled,
    setGridSize,
    setSnapToGrid,
    setShowGrid,
    setSnapToElements,

    // API Methods
    loadPages,
    loadBlocks,
    createPage,
    updatePage,
    deletePage,
    createBlock,
    updateBlock,
    deleteBlock,
    publishDrafts,
    discardDrafts: () => {
      setDraftChanges([]);
      localStorage.removeItem('cms_draft_changes');
      loadBlocks(currentPage?.id);
    },
    undo,
    redo,
    // Grid System
    gridColumns,
    gridRows,
    gridCellSize,
    gridGap,
    setGridColumns,
    setGridRows,
    setGridCellSize,
    setGridGap,

    // Utilities
    selectBlock,
    deselectAllBlocks,
    duplicateBlock,
    snapToGridValue,
    getSnapLines
  };

  return (
    <CMSContext.Provider value={value}>
      {children}
    </CMSContext.Provider>
  );
};
